Script started on Fri 24 Apr 2015 01:00:59 AM EDT
xxu85@matrix:~/oop244/finalproject> whoami
xxu85
xxu85@matrix:~/oop244/finalproject> cat *.h *.cpp aidapp.txt
#ifndef __244_AIDAPP_H__

#define __244_AIDAPP_H__

#include "Perishable.h"

#include "NFI.h"

#include "general.h"



namespace oop244{

  class AidApp{

    // private member arguments

	char _filename[256];

	Item* _items[MAX_NO_RECS];

	std::fstream datafile;

	int _noOfItems;



    // copy constructor and assingment operator

    // to prevent copying and assignment

	AidApp(const AidApp&);

	AidApp& operator=(const AidApp&);







    // private member fucntions

	int menu();

	void loadRecs();

	void saveRecs();

	void listItems()const;

	int SearchItems(const char* upc)const;

	void updateQty(const char* upc);

	void addItem(bool isPerishable);



public:

    // constructor and run member function

	AidApp(const char*);

	int run();



  };

}

#endif#ifndef __244_DATE_H__
#define __244_DATE_H__
// header file includes
#include <iostream>

namespace oop244{
	// Error code values gos here
	#define NO_ERROR   0  //No error the date is valid
	#define CIN_FAILED 1  //istream failed when entering information
	#define YEAR_ERROR 2  //Year value is invalid
	#define MON_ERROR  3  //Month value is invalid
	#define DAY_ERROR  4  //Day value is invalid
	
	class Date{
		
		private:
		// private member variables
		int _year;
		int _mon;
		int _day;
		int _readErrorCode;
		// privaet memeber functions and setters
		int value()const;
		void errCode(int errorCode);
		
		public:
		// constructors
		Date();
		Date(int,int,int);
		// operator overloads	
		bool operator==(const Date& D)const;
		bool operator!=(const Date& D)const;
		bool operator<(const Date& D)const;
		bool operator>(const Date& D)const;
		bool operator<=(const Date& D)const;
		bool operator>=(const Date& D)const;
		// IO member funcions
		std::istream& read(std::istream& istr);
		std::ostream& write(std::ostream& ostr)const;
		// public member fucntions and getters
		int errCode()const;
		bool bad()const;
		int mdays()const;
		void validate();
	
	};
	// operator << and >> overloads prototypes for ostream and istream go here
	std::istream& operator>>(std::istream&, Date&);
	std::ostream& operator<<(std::ostream&,const Date&);
}
#endif
// Final Project Milestone 4
// Error Massage class
// File ErrorMessage.h
// Version 1.0
// Date 2015/04/07
// Author Fardad Soleimanloo
//
// Revision History
// -----------------------------------------------------------
// Name               Date                 Reason
// Fardad             2015/04/07           Preliminary release
/////////////////////////////////////////////////////////////////
#ifndef __244_ERRORMESSAGE_H__
#define __244_ERRORMESSAGE_H__
#include <iostream>

class ErrorMessage{
  char _message[81];
public:
  ErrorMessage();
  virtual ~ErrorMessage();
  void clear();
  bool isClear()const;
  void message(const char* value);
  const char* message()const;
};
std::ostream& operator<<(std::ostream& os,const ErrorMessage& M);
#endif
#ifndef __244_ITEM__
#define __244_ITEM__
#include "general.h"

// header file includes
#include <iostream>
#include <fstream>
#include <cstring>
#include "Streamable.h"

namespace oop244{

  class Item : public Streamable {

  private:
		char _upc[MAX_UPC_LEN+1];
		char* _name;
		double _price;
		bool _taxed;
		int _quantity;
		int _qtyNeeded;

  public:
    // constructors
        Item();
		Item(const char*,const char*,double,int,bool Taxed = true);
		Item(const Item& src);

    // destructor
		~Item();

    // setters
		void upc(const char*);
		void price(double);
		void name(const char*);
		void taxed(bool);
		void quantity(int);
		void qtyNeeded(int);

    // getters
		const char* upc() const;
		double price() const;
		const char* name() const;
		bool taxed() const;
		int quantity() const;
		int qtyNeeded() const;
		double cost() const;

    // operators
		Item& operator=(const Item &src);
		bool operator==(const char*);
		int operator+=(int);

  };
  // Non-member operator overload prototype
  double operator+=(double& d, const Item& I);
}


#endif
#ifndef __244_NFI_H__
#define __244_NFI_H__

// includes go here
#include "Item.h"
#include "general.h"
#include "ErrorMessage.h"

namespace oop244{
  class NFI : public Item{
  private:
    ErrorMessage _err;
  public:
    // default constructor
	NFI();
    // pure virutal method implementation prototypes
	std::fstream& store(std::fstream&) const;
	std::fstream& load(std::fstream&);
    std::ostream& display(std::ostream&, bool) const;
    std::istream& conInput(std::istream&);
  };
}
#endif
#ifndef __244_Perishable_H__
#define __244_Perishable_H__
// includes go here
#include "general.h"
#include "Item.h"
#include "ErrorMessage.h"
#include "Date.h"
#include <cstring>
#include <iostream>
#include <fstream>

namespace oop244{
  class Perishable : public Item{
  private:
    ErrorMessage _err;
    // expiry and unit go here
	char _unit[11];
	Date _expiry;
  public:
    // default constructor
	Perishable();
    // pure virutal method implementation prototypes
    std::fstream& store(std::fstream&) const;
    std::fstream& load(std::fstream&);
    std::ostream& display(std::ostream&, bool) const;
    std::istream& conInput(std::istream&);
    // Setters and Getters
	const Date& expiry() const;
	void expiry(const Date& value);
	const char* unit() const;
	void unit(const char* value);
  };
}


#endif

#ifndef __244__Streamable__
#define __244__Streamable__
// hearfile includes:
#include <iostream>
#include <fstream>

namespace oop244{
  class Streamable{
  public:
    // pure virutal methods:
	virtual std::fstream& store(std::fstream&) const = 0;
	virtual std::fstream& load(std::fstream&) = 0;
	virtual std::ostream& display(std::ostream&, bool linear)const = 0;
	virtual std::istream& conInput(std::istream&) = 0;

    // virutal destructor:
    virtual ~Streamable(){}
  };
  // Non-memenber operator overoad prototypes for cin and cout:
	std::ostream& operator<<(std::ostream&,const Streamable&);
	std::istream& operator>>(std::istream&, Streamable&);

}
#endif


/**********   general.h   ******/

#ifndef __244_GENERAL_H__
#define __244_GENERAL_H__

#define TAX 		0.13
#define MAX_UPC_LEN	7
#define MIN_YEAR	2000
#define MAX_YEAR	2030
#define MAX_NO_RECS	2000

#endif

#include <cstring>
#include <new>
#include <iomanip>
#include "AidApp.h"
#include <cstdlib>

using namespace std;

namespace oop244{

	// copy constructor and assignment operator

	AidApp::AidApp(const AidApp& a){}

	AidApp& AidApp::operator=(const AidApp& a){
		return *this;
	}

	// constructor
	// copies filename to _filename
	// sets all the _items to null
	// sets _noOfItems to null
	// loads the Records
	AidApp::AidApp(const char* filename){
		strcpy(_filename, filename);
		for(int i = 0; i < MAX_NO_RECS; i++){
			_items[i] = nullptr;
		}
		_noOfItems = 0;
		loadRecs();
	}

	// Menu() displays the menu as follows and waits for the user to
	// select an option.
	// if the selection is valid, it will return the selection
	// if not it will return -1
	// this funtion makes sure there is no characters left in keyboard
	// and wipes it before exit.

	int AidApp::menu(){
		int selection;
		cout << "Disaster Aid Supply Management Program" << '\n';
		cout << "1 - List Items" << '\n';
		cout << "2 - Add Non-food item Item" << '\n';
		cout << "3 - Add Perishable item" << '\n';
		cout << "4 - Update item quantity" << '\n';
		cout << "0 - Exit program\n>";
		cin >> selection;
		cin.ignore(2000,'\n');
		if (selection < 0 || selection > 4){
			return -1;
		}
		else
			return selection;
	}

  // lists all the items in linear format on the screen

	void AidApp::listItems()const{
		double total;
		cout << " Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry" << '\n' << "-----|--------|--------------------|-------|----|----|----------|----------" << endl;
		for(int i = 0; i < _noOfItems; i++){
			cout <<  setw(4) <<  right << i+1 << " | " << *_items[i] << endl;
			total += *_items[i];
		}
		cout << "---------------------------------------------------------------------------" << '\n' << "Total cost of support: $" << fixed << setprecision(2) << total << endl;
	}

	// opens the file for writing
	// stores the items in the file
	// closes the file

	void AidApp::saveRecs(){
		datafile.open(_filename, ios::in| ios::out| ios::trunc);
		if(datafile.is_open()){
			for(int i = 0; i < _noOfItems; i++){
				_items[i]->store(datafile);
			}
		}
		else
			cout << "File is not open." <<  endl;
		datafile.close();
	}

	// Opens the file for reading, if it does not exist, it will create an
	// empty file and exits otherwise :
	// Loads Records from the file overwriting the old ones pointed by item.
	// This function makes sure when loading records into _item pointers, they
	// are deallocated before if they are already pointing to an item
	// closes the file

	void AidApp::loadRecs(){

		int readIndex = 0;
		char id;
		char buf;
		_items[0] = nullptr;
		datafile.open(_filename);
		if( datafile.fail()){
			datafile.clear();
			datafile.close();
			datafile.open(_filename,ios::out);
			datafile.close();
		}
		else{
			while(!datafile.eof()){
				if(_items[readIndex] != nullptr){
					delete _items[readIndex];
					_items[readIndex] = nullptr;
				}
				datafile >> id;
				datafile >> buf;
				if( id == 'P'){	
					Perishable* temp;
					temp = new Perishable;					
					temp->load(datafile);				
					_items[readIndex] = temp;					
					readIndex++;
				}
				else if( id == 'N'){		
					NFI* temp;
					temp = new NFI;
					temp -> load(datafile);
					_items[readIndex] = temp;
					readIndex++;
				}
			}		
			readIndex--; 
			datafile.close();
			_noOfItems = readIndex;		
		}
	}


	// Searchers for the item in the _items array with the same UPC.
	// if found, it will display the item in non-linear format and then
	// asks for the value of the items purchased, and if the value does not exceed
	// the number needed to fulfill the requirement, it will update the quantity onhand
	// value of the found record and then saves all the records to the file, overwriting
	// the old values

	void AidApp::updateQty(const char* UPC){
		int no;
		int index = SearchItems(UPC);
		if(index == -1)
			cout << "Not found!" <<  endl;
		else{
			_items[index]->display( cout,false); 
			cout << "\nPlease enter the number of purchased items: ";
			cin >> no;
			while( cin.fail()){
				cout << "Invalid Quantity value!" <<  endl;
				cin >> no;
			}		
			int qtyShort = _items[index]->qtyNeeded() - _items[index]->quantity();
			if(no <= qtyShort)
				*_items[index] += no; 
			else{
				int qtyNeeded = _items[index]->qtyNeeded();
				int quantityOH = _items[index]->quantity();
				_items[index]->quantity(qtyNeeded);
				cout << "Too much items, only " << qtyShort << " is needed, please return the extra " << no - qtyShort << " items" <<  endl;
			}
			saveRecs();
			cout << "Updated!" <<  endl;
		}
	}

	// searches for an item in the _items array for the same upc
	// if found it will return the index of the found item in _items
	// otherwise returns -1

	int AidApp::SearchItems(const char* upc) const{
		for (int i = 0; i < _noOfItems; i++){
			if(*_items[i] == upc){
				return i;
			}
		}
		return -1;
	}

	// creates a new item (NFI or Perishable) based on the argument
	// recieved dynamically, asks the user to fill in the values
	// if the user fills the values with no mistake, it will open the file
	// for writing, and then stores the item in the file.
	// and print a proper message.
	// if the user makes a mistake (cin fails) it will only display the item
	// to show the error.
	// in any way it will delete the item before exiting the function

	void AidApp::addItem(bool isPerishable){
		if(isPerishable){
			Perishable* temp;
			temp = new Perishable;
			temp -> conInput(std::cin);
			if(cin.fail()){
				temp -> display(std::cout, false);
				cin.ignore(2000,'\n');
				cin.clear();
			}
			else{
				_items[_noOfItems] = temp;
				datafile.open(_filename, ios::in| ios::out| ios::app);
				_items[_noOfItems]->store(datafile);
				_noOfItems++;
				datafile.close();
				saveRecs();
			}
		}
		else{
			NFI* temp;
			temp = new NFI();
			temp -> conInput(std::cin);
			if(cin.fail()){
				temp -> display(std::cout, false);
				cin.ignore(2000,'\n');
				cin.clear();
			}
			else{
				_items[_noOfItems] = temp;
				datafile.open(_filename, ios::in| ios::out| ios::app);
				_items[_noOfItems]->store(datafile);
				_noOfItems++;
				datafile.close();
				saveRecs();
			}
		}
	}
	
	// diplays the menu and receives the user selection
	// if valid, it will preform the action requsted:
	// 1, lists the items in the file on the screen
	// 2 and 3, adds the item and then re-loads the records
	//     from the file into the AidApp
	// 4, gets a UPC and then updates the quantity of it
	// 0, exits the program.

	int AidApp::run(){
		int selection;
		char UPC[MAX_UPC_LEN + 1];
		selection = menu();
		do{
			while(selection == -1){
				cout << "===Invalid Selection, try again.===" << endl;
				selection = menu();
			}
			switch (selection){
				case 1 : 
					listItems();break; 
				case 2 : 
					addItem(false);cin.ignore(2000,'\n');break;
				case 3 : 
					addItem(true);cin.ignore(2000,'\n');break;
				default :
					cout << "Please enter the UPC: ";
					cin >> UPC;
					cin.ignore(2000,'\n');
					updateQty(UPC);
					break;
			}
			
			selection = menu();
		} while(selection);
			cout << "Good Bye!" << endl;
		return 0;
	}
}
	
#include "Date.h"
#include "general.h"
#include <iomanip>
#include <iostream>
using namespace std;

namespace oop244{

	// returns a uniqe value out of date
	// this value is used to compare two dates
	int Date::value()const{
		return _year * 372 + _mon * 31 + _day;
	}
	
	// validate(), this is an optional private function to write
	// for validation logic and setting the _readErrorCode.
	// see the read() funciton description for more detail
	void Date::validate(){
		if(_year <= MAX_YEAR && _year>=MIN_YEAR){
			if( _mon >= 1 && _mon <= 12 ){
				if(_day <= mdays() && _day >=0){
					errCode(NO_ERROR);
				}
				else{
					errCode(DAY_ERROR);			
				}
			}
			else{
				errCode(MON_ERROR);
			}
		}
		else{
			errCode(YEAR_ERROR);
		}
	}

	// mday():
	// returns the day of the month.
	// _mon value must be set for this to work
	// if _mon is invalid, this function returns -1
	// leap years are considered in this logic
	int Date::mdays()const{
		int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, -1 };
		int mon = _mon >= 1 && _mon <= 12 ? _mon : 13;
		mon--;
		return days[mon] + int((mon == 1)*((_year % 4 == 0) && (_year % 100 != 0)) || (_year % 400 == 0));
	}
	
	// constructors
	Date::Date(){
		_year=0;
		_mon=0;
		_day=0;
		errCode(NO_ERROR);
	}
		
	Date::Date(int y,int m,int d){
		_year=y;
		_mon=m;
		_day=d;
		errCode(NO_ERROR);
	}
	
	// member fucntions
	void Date::errCode(int errorCode){
		switch(errorCode){
			case 1:
				_readErrorCode=1;
				break;
			case 2:
				_readErrorCode=2;
				break;
			case 3:
				_readErrorCode=3;
				break;
			case 4:
				_readErrorCode=4;
				break;
			default:
				_readErrorCode=0;
		}
	}
	
	int Date::errCode()const{
		return _readErrorCode;
	}

	bool Date::bad()const{
		if (_readErrorCode!=0){
			return true;
		}
		else{
			return false;
		}
	}

	// operators
	bool Date::operator==(const Date& D)const{
	if (value()==D.value()){
		return true;
	}
	else{
		return false;
	}
}

	bool Date::operator!=(const Date& D)const{
		if (value()!=D.value()){
			return true;
		}
		else{
			return false;
		}
	}

	bool Date::operator<(const Date& D)const{
		if (value()<D.value()){
			return true;
		}
		else{
			return false;
		}
	}

	bool Date::operator>(const Date& D)const{
		if (value()>D.value()){
			return true;
		}
		else{
			return false;
		}
	}

	bool Date::operator<=(const Date& D)const{
		if (value()<=D.value()){
			return true;
		}
		else{
			return false;
		}
	}

	bool Date::operator>=(const Date& D)const{
		if (value()>=D.value()){
			return true;
		}
		else{
			return false;
		}
	}

	// IO funtions
	std::istream& Date::read(std::istream& istr){	
		char a;
		
		istr >> _year >> a >> _mon >> a >> _day;
		validate();
		
		if(istr.fail()){
			errCode(CIN_FAILED);
		}
		
		return istr;
	}

	std::ostream& Date::write(std::ostream& ostr)const{
		ostr << _year << "/" << _mon << "/" << _day ;
		return ostr;
	}

	// non-memeber operator overloads
	std::istream& operator>>(std::istream& istr, Date& D){
		D.read(istr);
		return istr;
	}

	std::ostream& operator<<(std::ostream& ostr,const Date& D){
		D.write(ostr);
		return ostr;
	}
}
#include "ErrorMessage.h"
#include <cstring>

ErrorMessage::ErrorMessage(){  // sets messaage to an empty string
  _message[0] = 0;
}


ErrorMessage::~ErrorMessage(){}


void ErrorMessage::clear(){   // clears the message to an empty string
  _message[0] = 0;
}


bool ErrorMessage::isClear()const{  // returns true if the message is empty ( NO Error)
  return _message[0] == 0;
}


void ErrorMessage::message(const char* value){  // copies the value string into the _message string (sets the error message)
  std::strncpy(_message, value, 80);
  _message[80] = 0;
}

const char* ErrorMessage::message()const{  // returns the error message
  return _message;
}

std::ostream& operator<<(std::ostream& os,const ErrorMessage& M){   // prints the ErrorMessage object using ostream
  return os << M.message();
}
// header file includes
#include "Item.h"
#include <cstring>
namespace oop244{

  // constructors
    Item::Item(){
        _upc[0]='\0';
        _name=nullptr;
        _price=0;
        _quantity=0;
        _qtyNeeded=0;
        _taxed=true;
    }

	Item::Item(const char* upc,const char* name,double price,int qtyNeeded,bool taxed){
        strncpy(_upc,upc,MAX_UPC_LEN+1);
		_name = new char[strlen(name)+1];
		strcpy(_name,name);
		_price = price;
		_quantity = 0;
		_qtyNeeded = qtyNeeded;
		_taxed = taxed;
	}


	Item::Item(const Item& src){
		upc(src._upc);
		if(src._name != nullptr){
			_name = new char[strlen(src._name)+1];
			name(src._name);
		}
		else{
			_name=nullptr;
		}
		price(src._price);
		qtyNeeded(src._qtyNeeded);
		taxed(src._taxed);
        quantity(0);
	}

  // operator=
	Item& Item::operator=(const Item& src){
	    if(this != &src){
            upc(src._upc);
            name(src._name);
            price(src._price);
            qtyNeeded(src._qtyNeeded);
            taxed(src._taxed);
            quantity(0);

	    }
		return *this;
	}



  // setters
	void Item::upc(const char* upc){
        strncpy(_upc,upc,MAX_UPC_LEN+1);
	}

	void Item::price(double price){
		_price = price;
	}

	void Item::name(const char* name){
		delete [] _name;
		if(name !=  nullptr){
			_name = new char[strlen(name)+1];
			strcpy(_name,name);
		}
		else{
			_name=nullptr;
		}
	}

	void Item::taxed(bool taxed){
		_taxed = taxed;
	}

	void Item::quantity(int quantity){
		_quantity = quantity;
	}

	void Item::qtyNeeded(int qtyNeeded){
		_qtyNeeded = qtyNeeded;
	}

  // getters
	const char* Item::upc() const{
		return _upc;
	}

	double Item::price() const{
		return _price;
	}

	const char* Item::name() const{
		return _name;
	}

	bool Item::taxed() const{
		return _taxed;
	}

	int Item::quantity() const{
		return _quantity;
	}

	int Item::qtyNeeded() const{
		return _qtyNeeded;
	}

	double Item::cost() const{
		if(_taxed){
			return _price*(1+TAX);
		}
		else{
			return _price;
		}
	}

  // member operator overloads
	bool Item::operator==(const char* upc){
		if(!strcmp(_upc,upc)){
			return true;
		}
		else{
			return false;
		}
	}

	int Item::operator+=(int quantity){
		_quantity += quantity;
		return _quantity;
	}

  // non-member operator overload
	 double operator+=(double& d, const Item& I){
		double cost=I.cost();
		int quantity=I.quantity();
		d += cost * quantity;
		return d;
	 }

  // destructor
	Item::~Item(){
		if(_name != nullptr){
			delete [] _name;
		}
		_name = nullptr;
	}
}
//includes go here
#include <iostream>
#include <fstream>
#include <iomanip>
#include "NFI.h"
#include "general.h"

namespace oop244{
  // constructor
	NFI::NFI(){
		qtyNeeded(1);
		taxed(1);
	}

  // fstream& NFI::store(fstream& file)const
	std::fstream& NFI::store(std::fstream& file) const{
		if (file.is_open()){
			file << "N," << upc() << "," << name()<< ","  << price() << "," << quantity() << "," << qtyNeeded() << std::endl;
		}
		return file;
	}

  // fstream& NFI::load(fstream& file)
	std::fstream& NFI::load(std::fstream& file){
		char upc_[MAX_UPC_LEN+1];
		char name_[21];
		double price_;
		int quantity_;
		int qtyNeeded_;
		
		if(file.is_open() && file.good()){
			file.getline(upc_,MAX_UPC_LEN + 1, ',');
			file.getline(name_, 21, ',');  
			file >> price_;
			file.ignore(); 
			file >> quantity_;
			file.ignore();  
			file >> qtyNeeded_;
		}
		upc(upc_);
		name(name_);
		price(price_);
		quantity(quantity_);
		qtyNeeded(qtyNeeded_);
		return file;  
	}

  // ostream& NFI::display(ostream& ostr, bool linear)const
	std::ostream& NFI::display(std::ostream& ostr, bool linear) const{
		if(!_err.isClear()){
			return ostr << _err.message();
		}
		else{
			if(linear){
				ostr << std::setw(MAX_UPC_LEN) << std::left << upc() << "|" << std::setw(20) << std::left << name() << "|" << std::fixed << std::right << std::setw(7) << std::setprecision(2) << cost() << "|" << std::right << std::setw(4) << quantity() << "|" << std::right << std::setw(4) << qtyNeeded();
			}
			else{
				ostr << "Upc: " << upc() << '\n' << "Name: " << name() << '\n' << "Price: " << price() << '\n' << "Price after tax: " << cost() << '\n' << "Quantity On Hand: " << quantity() << '\n' << "Quantity Needed: " << qtyNeeded() << std::endl;
			}
		}
		return ostr;
	}

  // istream& NFI::conInput(istream& istr)
	 std::istream& NFI::conInput(std::istream& istr){
		char upc_[MAX_UPC_LEN+1];
		char name_[21];
		double price_;
		int quantity_;
		int qtyNeeded_;
		int invalid=0;

		_err.clear();
		istr.clear();

		std::cout << "Non-Food Item Entry:" << '\n' << "Upc: ";
		istr >> upc_;
		istr.ignore(2000,'\n');
		std::cout << "Name: ";
		istr >> name_;
		istr.ignore(2000,'\n');
		std::cout << "Price: ";
		istr >> price_;

		if(istr.fail()){
			_err.message("Invalid Price Entry");
			istr.ignore(2000,'\n');
			invalid++;
		}
		else{
			std::cout << "Quantity On Hand: ";
			istr >> quantity_;
			if(istr.fail()){
				_err.message("Invalid Quantity Entry");
				istr.ignore(2000,'\n');
				invalid++;
			}
			else{
				std::cout << "Quantity Needed: ";
				istr >> qtyNeeded_;
				if(istr.fail()){
					_err.message("Invalid Quantity Needed Entry");
					istr.ignore(2000,'\n');
					invalid++;
				}
			}
		}

		if(!invalid){
			upc(upc_);
			name(name_);
			price(price_);
			quantity(quantity_);
			qtyNeeded(qtyNeeded_);
		}

		return istr;
	 }
}

// includes go here
#include <iostream>
#include <fstream>
#include "Perishable.h"
#include <iomanip>

namespace oop244{
  // constructor
	Perishable::Perishable(){
		qtyNeeded(1);
		taxed(false);
		_unit[0] = '\0';
	}

  // Setters and getters
	const Date& Perishable::expiry() const{
		return _expiry;
	}

	void Perishable::expiry(const Date& value){
		_expiry = value;
	}

	const char* Perishable::unit() const{
		return _unit;
	}

	void Perishable::unit(const char* value){
		strncpy(_unit,value,11);
	}

  // fstream& Perishable::store(fstream& file)const
	std::fstream& Perishable::store(std::fstream& file)const{
		if (!file.is_open()) {
			std::cerr << "File is not open" << std::endl;
		}
		else{
			file << "P," << upc() << "," << name()<< ","  << price() << ","  << unit() << ","<< quantity() << ","<< qtyNeeded() << ","<< expiry()<< std::endl;
		}
		return file;
	}
  //fstream& Perishable::load(fstream& file)
    std::fstream& Perishable::load(std::fstream& file){
        char upc_[MAX_UPC_LEN + 1];
        char name_[21];
        char unit[11];
        double price_;
        int quantity_;
        int qtyNeeded_;
        char comma;
		int year,month,day;
        if(file.is_open() && file.good()){
                file.getline(upc_,MAX_UPC_LEN + 1,',');
                file.getline(name_,21,',');
				file >> price_;
				file.ignore();
                file.getline(unit,11,',');
				file >> quantity_ ;
				file.ignore();
				file >> qtyNeeded_ ;
				file.ignore();
                file >> year >> comma >> month >> comma >> day;
				file.ignore(2000,'\n');
        }

        upc(upc_);
        name(name_);
        price(price_);
        quantity(quantity_);
        qtyNeeded(qtyNeeded_);
        strncpy(_unit,unit,11);
		Date expiry(year,month,day);
		_expiry=expiry;
        return file;
}
  //ostream& Perishable::display(ostream& os, bool linear)const
    std::ostream& Perishable::display(std::ostream& ostr, bool linear)const{
        if(!_err.isClear())
            return ostr << _err.message();
        else{
            if(linear){
                ostr << std::setw(MAX_UPC_LEN) << std::left << upc() << "|" << std::setw(20) << std::left << name() << "|" << std::fixed << std::right << std::setw(7) << std::setprecision(2) << cost() << "|";
                ostr << std::right << std::setw(4) << quantity() << "|" << std::right << std::setw(4) << qtyNeeded() << "|" << std::left << std::setw(10) << _unit << "|" << _expiry;
            }
            else
                ostr << "Upc:" << upc() << std::endl << "Name:" << name() << std::endl << "Price:" << price() << std::endl << "Price after tax:" << cost() << std::endl << "Quantity On Hand: " << quantity() << std::endl << "Quantity Needed: " << qtyNeeded() << std::endl << "Unit: " << _unit << std::endl << "Expiry date: " << _expiry <<std::endl;
        }

        return ostr;
    }
  // istream& Perishable::conInput(istream& is)
    std::istream& Perishable::conInput(std::istream& istr){
    char upc_[MAX_UPC_LEN + 1];
    char name_[21];
    double price_;
    int quantity_;
    int qtyNeeded_;
	char unit[11];
	int invalid=0;
	Date expiry_;
	_err.clear();
	istr.clear();
	std::cout << "Perishable Item Entry:" << std::endl << "Upc: ";
	istr >> upc_;
	istr.ignore(2000,'\n');
    std::cout << "Name: ";
    istr >> name_;
	istr.ignore(2000,'\n');
    std::cout << "Price: ";
    istr >> price_;
	if(istr.fail()){
        _err.message("Invalid Price Entry");
        istr.ignore(2000,'\n');
		invalid++;
    }
	else{
	    std::cout << "Quantity On Hand: ";
    	istr >> quantity_;
    	if(istr.fail()){
        	_err.message("Invalid Quantity Entry");
        	istr.ignore(2000,'\n');
			invalid++;
    	}
		else{
    		std::cout << "Quantity Needed: ";
    		istr >> qtyNeeded_;
	   		if(istr.fail()){
        		_err.message("Invalid Quantity Needed Entry");
        		istr.ignore(2000,'\n');
				invalid++;
    		}
			else{
				std::cout << "Unit: ";
				istr >> unit;
				istr.ignore(2000,'\n');	
				std::cout << "Expiry date (YYYY/MM/DD) : ";
				istr >> expiry_;
				istr.ignore(2000,'\n');	
				if(expiry_.bad()){
					invalid++;
					istr.setstate(std::ios::failbit);
				}
				if(expiry_.errCode() == 1)
					_err.message("Invalid Date Entry");
				else if(expiry_.errCode() == 2)
						_err.message("Invalid Year in Date Entry");
					else if(expiry_.errCode() == 3)
							_err.message("Invalid Month in Date Entry");
							else if(expiry_.errCode() == 4)
								_err.message("Invalid Day in Date Entry");
								else {
									_expiry = expiry_;
								}
				}
		}
	}
	if(!invalid){
		upc(upc_);
        name(name_);
        price(price_);
        quantity(quantity_);
        qtyNeeded(qtyNeeded_);
		strncpy(_unit,unit,11);
		
	}
	return istr;
    }
}

#include "Streamable.h"
#include <iostream>
namespace oop244{

  // Non-memenber operator overoad implementation for cin and cout:
	std::ostream& operator<<(std::ostream& os ,const Streamable& S){
		S.display(os,true);
		return os;
	}

	std::istream& operator>>(std::istream& is, Streamable& S){
		S.conInput(is);
		return is;
	}
}
#include "AidApp.h"
int main(){
  oop244::AidApp app("aidapp.txt");
  return app.run();
}P,123,Rice and Beans,12,Bags,200,200,2018/12/22
N,122,Bucket,10,150,300
P,124,Corn,4,Packs,0,140,2018/4/3
N,200,Blanket,20,10,50
P,132,Banana,0.99,Kilos,6,10,2015/5/13
N,111,Water Container,11.32,19,400
xxu85@matrix:~/oop244/finalproject> g++ -std=c++0x -o finalproject *.cpp
xxu85@matrix:~/oop244/finalproject> finalproject
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>1
 Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry
-----|--------|--------------------|-------|----|----|----------|----------
   1 | 123    |Rice and Beans      |  12.00| 200| 200|Bags      |2018/12/22
   2 | 122    |Bucket              |  11.30| 150| 300
   3 | 124    |Corn                |   4.00|   0| 140|Packs     |2018/4/3
   4 | 200    |Blanket             |  22.60|  10|  50
   5 | 132    |Banana              |   0.99|   6|  10|Kilos     |2015/5/13
   6 | 111    |Water Container     |  12.79|  19| 400
---------------------------------------------------------------------------
Total cost of support: $4569.98
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>2
Non-Food Item Entry:
Upc: 222
Name: Clothes
Price: 20
Quantity On Hand: 2
Quantity Needed: 4
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>1
 Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry
-----|--------|--------------------|-------|----|----|----------|----------
   1 | 123    |Rice and Beans      |  12.00| 200| 200|Bags      |2018/12/22
   2 | 122    |Bucket              |  11.30| 150| 300
   3 | 124    |Corn                |   4.00|   0| 140|Packs     |2018/4/3
   4 | 200    |Blanket             |  22.60|  10|  50
   5 | 132    |Banana              |   0.99|   6|  10|Kilos     |2015/5/13
   6 | 111    |Water Container     |  12.79|  19| 400
   7 | 222    |Clothes             |  22.60|   2|   4
---------------------------------------------------------------------------
Total cost of support: $4615.18
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>4
Please enter the UPC: 222
Upc: 222
Name: Clothes
Price: 20.00
Price after tax: 22.60
Quantity On Hand: 2
Quantity Needed: 4

Please enter the number of purchased items: 2
Updated!
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>1
 Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry
-----|--------|--------------------|-------|----|----|----------|----------
   1 | 123    |Rice and Beans      |  12.00| 200| 200|Bags      |2018/12/22
   2 | 122    |Bucket              |  11.30| 150| 300
   3 | 124    |Corn                |   4.00|   0| 140|Packs     |2018/4/3
   4 | 200    |Blanket             |  22.60|  10|  50
   5 | 132    |Banana              |   0.99|   6|  10|Kilos     |2015/5/13
   6 | 111    |Water Container     |  12.79|  19| 400
   7 | 222    |Clothes             |  22.60|   4|   4
---------------------------------------------------------------------------
Total cost of support: $4660.38
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>4
Please enter the UPC: 222
Upc: 222
Name: Clothes
Price: 20.00
Price after tax: 22.60
Quantity On Hand: 4
Quantity Needed: 4

Please enter the number of purchased items: 5
Too much items, only 0 is needed, please return the extra 5 items
Updated!
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>1
 Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry
-----|--------|--------------------|-------|----|----|----------|----------
   1 | 123    |Rice and Beans      |  12.00| 200| 200|Bags      |2018/12/22
   2 | 122    |Bucket              |  11.30| 150| 300
   3 | 124    |Corn                |   4.00|   0| 140|Packs     |2018/4/3
   4 | 200    |Blanket             |  22.60|  10|  50
   5 | 132    |Banana              |   0.99|   6|  10|Kilos     |2015/5/13
   6 | 111    |Water Container     |  12.79|  19| 400
   7 | 222    |Clothes             |  22.60|   4|   4
---------------------------------------------------------------------------
Total cost of support: $4660.38
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>3
Perishable Item Entry:
Upc: 333
Name: water
Price: 1
Quantity On Hand: 3
Quantity Needed: 4
Unit: bottle
Expiry date (YYYY/MM/DD) : 2017/10/17

Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>1
 Row | UPC    | Item Name          | Cost  | QTY|Need| Unit     | Expiry
-----|--------|--------------------|-------|----|----|----------|----------
   1 | 123    |Rice and Beans      |  12.00| 200| 200|Bags      |2018/12/22
   2 | 122    |Bucket              |  11.30| 150| 300
   3 | 124    |Corn                |   4.00|   0| 140|Packs     |2018/4/3
   4 | 200    |Blanket             |  22.60|  10|  50
   5 | 132    |Banana              |   0.99|   6|  10|Kilos     |2015/5/13
   6 | 111    |Water Container     |  12.79|  19| 400
   7 | 222    |Clothes             |  22.60|   4|   4
   8 | 333    |water               |   1.00|   3|   4|bottle    |2017/10/17
---------------------------------------------------------------------------
Total cost of support: $4663.38
Disaster Aid Supply Management Program
1 - List Items
2 - Add Non-food item Item
3 - Add Perishable item
4 - Update item quantity
0 - Exit program
>0
Good Bye!
xxu85@matrix:~/oop244/finalproject> exit
exit

Script done on Fri 24 Apr 2015 01:03:22 AM EDT
